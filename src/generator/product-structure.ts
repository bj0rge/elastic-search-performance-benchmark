export type ProductStructure = {
  name: string;
  [fieldName: string]: string;
};

export type ProductStructureConfig = {
  additionalFields: number;
  totalWords: number;
};

export type FieldDefinition = {
  name: string;
  wordCount: number;
};

export const generateProductStructure = (
  config: ProductStructureConfig
): FieldDefinition[] => {
  const { additionalFields, totalWords } = config;

  if (additionalFields > totalWords) {
    throw new Error(
      `Cannot create ${additionalFields} fields with only ${totalWords} words. ` +
        `Each field needs at least 1 word. Maximum fields: ${totalWords}`
    );
  }

  const fields: FieldDefinition[] = [{ name: "name", wordCount: 0 }];

  if (additionalFields === 0) {
    fields.push({ name: "description", wordCount: totalWords });
    return fields;
  }

  const baseWordsPerField = Math.floor(totalWords / additionalFields);
  const remainingWords = totalWords % additionalFields;

  // Generate random word counts for each field
  const randomWordCounts: number[] = [];
  let totalRandomWords = 0;

  // First pass: generate initial random counts
  for (let i = 0; i < additionalFields; i++) {
    const minWords = Math.max(1, Math.floor(baseWordsPerField * 0.2));
    const maxWords = Math.floor(baseWordsPerField * 1.8);
    const randomCount =
      Math.floor(Math.random() * (maxWords - minWords + 1)) + minWords;
    randomWordCounts.push(randomCount);
    totalRandomWords += randomCount;
  }

  // Second pass: adjust to match totalWords
  const difference = totalWords - totalRandomWords;
  if (difference !== 0) {
    const adjustmentPerField = Math.floor(difference / additionalFields);
    const extraAdjustment = difference % additionalFields;

    for (let i = 0; i < additionalFields; i++) {
      randomWordCounts[i] += adjustmentPerField;
      if (i < extraAdjustment) {
        randomWordCounts[i] += 1;
      }
    }
  }

  // Create field definitions with the adjusted random counts
  for (let i = 1; i <= additionalFields; i++) {
    fields.push({
      name: `field${i}`,
      wordCount: randomWordCounts[i - 1],
    });
  }

  return fields;
};

export const validateProductStructureConfig = (
  config: ProductStructureConfig
): void => {
  if (config.additionalFields < 0) {
    throw new Error("Number of additional fields must be >= 0");
  }

  if (config.totalWords < 1) {
    throw new Error("Total words must be >= 1");
  }

  if (config.additionalFields > config.totalWords) {
    throw new Error(
      `Cannot create ${config.additionalFields} fields with only ${config.totalWords} words`
    );
  }
};

export const logProductStructure = (
  fields: FieldDefinition[],
  verbose: boolean = true
): void => {
  if (!verbose) return;

  console.log("ðŸ“‹ Generated Product Structure:");
  fields.forEach((field) => {
    if (field.name === "name") {
      console.log(`  - ${field.name}: <generated by faker>`);
    } else {
      console.log(`  - ${field.name}: ${field.wordCount} words`);
    }
  });

  const totalWords = fields.reduce((sum, field) => sum + field.wordCount, 0);
  console.log(`  ðŸ“Š Total content words: ${totalWords}`);
};
